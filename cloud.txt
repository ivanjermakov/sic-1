{"sic1_Puzzle_Stack Memory":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":19,\"solutionBytes\":36,\"solutions\":[{\"name\":\"Untitled\",\"code\":null,\"solutionCycles\":19,\"solutionBytes\":36}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Number to Sequence":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":64,\"solutionBytes\":26,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @n @IN\\nsubleq @n @n1 @inner\\n\\n@done:\\nsubleq @OUT @0\\nsubleq @n @n @loop\\n\\n@inner:\\nsubleq @OUT @n1\\nsubleq @n @n1 @inner\\nsubleq @n @n @done\\n\\n@n: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\\n@1: .data 1\",\"solutionCycles\":64,\"solutionBytes\":26}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Self-Modifying Code":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":46,\"solutionBytes\":15,\"solutions\":[{\"name\":\"Untitled\",\"code\":null}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Calculator":"{\"unlocked\":true,\"viewed\":false,\"solved\":false,\"solutions\":[{\"name\":\"Untitled\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Sandbox Mode":"{\"unlocked\":true,\"viewed\":true,\"solved\":false,\"solutions\":[{\"name\":\"selfdestruct\",\"code\":\".data -3\\n\",\"customInput\":\"-3\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"},{\"name\":\"ret\",\"code\":\"@start:\\nsubleq @rp @rp\\nsubleq @rp @r1\\nsubleq @0 @0 @proc_foo\\n\\nsubleq @rp @rp\\nsubleq @rp @r2\\nsubleq @0 @0 @proc_foo\\n\\nsubleq @0 @0 @HALT\\n\\n; arbitrary procedure that will jump to rp once finished\\n@proc_foo:\\nsubleq @OUT @0\\nsubleq @a @a @ret\\n\\n@ret:\\nsubleq @a @a @rp:255 ; PATCH\\n\\n; return consts\\n@r1: .data -9\\n@r2: .data -18\\n\\n; tmp registers\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n@1: .data 1\\n@n1: .data -1\\n@0: .data 0\",\"customInput\":\"1 1 67 9\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"},{\"name\":\"std\",\"code\":\"@start:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @n_arr_p\\n\\tsubleq @0 @0 @read_arr @start_ret:\\n\\tsubleq @OUT @xr\\n@start_loop:\\t\\n\\tsubleq @0 @0 @start\\n\\t\\n@start_nrp: .data -@start_ret\\n\\n\\n@arr: .data 0, 0, 0, 0, 0\\n@n_arr_p: .data -@arr\\n\\n; STD\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i and\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\t!subleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @0 @0 @ret\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_ret\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_ret\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n@eq_ret:\\n\\tsubleq @0 @0 @ret\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n\\tsubleq @has_rpb @has_rpb\\n\\tsubleq @has_rpb @rp\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_nrp\\n\\tsubleq @0 @0 @eq @has_ret:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @0 @0 @ret\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n@has_nrp: .data -@has_ret\\n@has_rpb: .data 0\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n\",\"customInput\":\"3 6 0\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"}],\"currentSolutionName\":\"std\"}","sic1_Puzzle_Data Directive and Looping":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":3,\"solutionBytes\":5,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Custom labels are defined by putting \\\"@name: \\\" at the beginning of\\n; a line, e.g.:\\n;\\n;   @loop: subleq 1, 2\\n;\\n; In addition to \\\"subleq\\\", there is an assembler directive \\\".data\\\"\\n; that sets a byte of memory to a value at compile time (note: this\\n; is not an instruction!):\\n;\\n;   .data <X>\\n;\\n; X is a signed byte between -128 and 127 (inclusive).\\n;\\n; Combining labels and the \\\".data\\\" directive allows you to develop a\\n; system of constants and variables. For example, here a byte is set\\n; to zero, and the label @zero points to that value:\\n;\\n;   @zero: .data 0\\n;\\n; Note that, while a program is executing, you can view the current\\n; value of each variable in the variable table on the right (under\\n; the memory table).\\n;\\n; Variables can be used for implementing an unconditional jump:\\n;\\n;   subleq @zero, @zero, @next\\n;\\n; This will set @zero to @zero - @zero (still zero) and, since the\\n; result is always <= 0, execution branches to @next.\\n;\\n; Below is an updated negation program that repeatedly negates input\\n; values and writes them out in a loop.\\n\\n@loop:\\nsubleq @OUT @IN @loop\\n\\n\",\"solutionCycles\":3,\"solutionBytes\":5}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_First Assessment":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":8,\"solutionBytes\":12,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Now that you understand the \\\"subleq\\\" instruction, the \\\".data\\\"\\n; directive, and labels, you should be able to read values from input\\n; and write the exact same values out, by negating the value twice.\\n;\\n; Below is an almost complete solution. You will need to replace\\n; instances of \\\"???\\\". Hint: use a label that points to a storage\\n; location for a (negated) value.\\n\\n@loop:\\nsubleq @tmp, @IN\\nsubleq @OUT, @tmp\\nsubleq @tmp, @tmp, @loop  ; Reset @tmp to zero, and jump to @loop\\n\\n@tmp: .data 0\\n\",\"solutionCycles\":8,\"solutionBytes\":12}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Parse Decimal":"{\"unlocked\":true,\"viewed\":false,\"solved\":false,\"solutions\":[{\"name\":\"Untitled\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Reverse Sequence":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":335,\"solutionBytes\":97,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@read:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @print\\n@m1:\\nsubleq 128 128 ; SELF MODIFIED\\nsubleq 128 @a ; SELF MODIFIED\\nsubleq @a @a\\n\\nsubleq @m1 @n1\\nsubleq @m1+1 @n1\\nsubleq @m1+3 @n1\\nsubleq @m2+1 @n1\\nsubleq @a @a @read\\n\\n@print:\\nsubleq @m1 @1\\nsubleq @m1+1 @1\\nsubleq @m1+3 @1\\nsubleq @m2+1 @1\\n\\nsubleq @a @a\\n@m2:\\nsubleq @a 128 ; SELF MODIFIED\\nsubleq @OUT @a\\n\\nsubleq @a @a\\nsubleq @a @m1\\nsubleq @a @n128 @print\\n\\n; HACK\\nsubleq @m1 @n1\\nsubleq @m1+1 @n1\\nsubleq @m1+3 @n1\\nsubleq @m2+1 @n1\\n\\nsubleq @a @a @read\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@1: .data 1\\n@n1: .data -1\\n@0: .data 0\\n@n128: .data -128\",\"solutionCycles\":335,\"solutionBytes\":97}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Mode":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; TODO: improve by limiting scan to [input min, input max] instead of [0, 99]\\n@loop:\\n@reset:\\nsubleq @reset_c @reset_c\\nsubleq @reset_c @reset_s\\nsubleq @reset_i @reset_i\\nsubleq @reset_i @a_np\\nsubleq @reset_i+1 @reset_i+1\\nsubleq @reset_i+1 @a_np\\n\\n@reset_arr:\\nsubleq @reset_i:0 @reset_i\\nsubleq @reset_i @n_1\\nsubleq @reset_i+1 @n_1\\nsubleq @reset_c @n_1 @reset_arr\\n\\n@read:\\nsubleq @a @IN\\nsubleq @arr_i @arr_i\\nsubleq @arr_i @arr_np\\nsubleq @arr_i @a\\nsubleq @arr_i:0 @n_1\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @find\\nsubleq @a @a @read\\n\\n@find:\\nsubleq @arr_j @arr_j\\nsubleq @arr_j @arr_np\\nsubleq @maxc @maxc\\n\\n@find_l:\\nsubleq @a @a\\nsubleq @a @arr_j:0\\n\\nsubleq @b @b\\nsubleq @b @maxc\\nsubleq @c @c\\nsubleq @b @a @find_cont\\n\\n@update:\\nsubleq @maxc @maxc\\nsubleq @maxc @a\\nsubleq @b @b\\nsubleq @b @i\\nsubleq @max_i @max_i\\nsubleq @max_i @b\\n\\n@find_cont:\\nsubleq @b @b\\nsubleq @b @i\\nsubleq @b @n_99 @found\\nsubleq @i @n_1\\nsubleq @arr_j @n_1\\nsubleq @a @a @find_l\\n\\n@found:\\nsubleq @a @a\\nsubleq @a @max_i\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@arr_np: .data -@arr\\n@a_np: .data -@a\\n@0: .data 0\\n@n_1: .data -1\\n@n_99: .data -99\\n\\n@reset_c: .data 0\\n@reset_s: .data 106\\n\\n;resettable\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@i: .data 0\\n@max_i: .data 0\\n@maxc: .data 0\\n@arr: .data 0 ; actuall size is 100\"}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":5168,\"solutionBytes\":248}","sic1_Puzzle_Indicator Function":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"using ret, not enough memory\",\"code\":\"@start:\\n\\tsubleq @loop_b_i @loop_b_i\\n\\tsubleq @loop_b_i @arr_b_np\\n@read_a:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_a_np\\n\\tsubleq @0 @0 @read_arr @start_ret:\\n@read_b:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp2\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_b_np\\n\\tsubleq @0 @0 @read_arr @start_ret2:\\n@loop_b:\\n\\tsubleq @a @a\\n\\tsubleq @a @loop_b_i:255\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @xa @xa\\n\\tsubleq @xa @a\\n\\tsubleq @xa @0 @restart\\n\\t\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp3\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @0 @0 @has @start_ret3:\\n\\n\\tsubleq @a @a\\n\\tsubleq @a @xr\\n\\tsubleq @OUT @a\\n@loop_b_cont:\\n\\tsubleq @loop_b_i @n_1\\n\\tsubleq @0 @0 @loop_b\\t\\n@restart:\\n\\tsubleq @a @a\\n\\tsubleq @a @arr_a_np\\n@reset_loop:\\n\\t.data -12 @n_1 @reset_loop+3\\n\\t;subleq @reset_c:12 @n1\\n\\t;subleq @a @a\\n\\t;subleq @reset_c @n1 @restart2\\n\\t;subleq @0 @0 @start\\n@restart2:\\n\\t!subleq @0 @0 @start\\n\\t\\n@start_nrp: .data -@start_ret\\n@start_nrp2: .data -@start_ret2\\n@start_nrp3: .data -@start_ret3\\n\\n\\n@arr_a: .data 0 0 0 0 0 0\\n@arr_b: .data 0 0 0 0 0 0\\n@arr_a_np: .data -@arr_a\\n@arr_b_np: .data -@arr_b\\n\\n; STD\\n\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\tsubleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @0 @0 @ret\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_ret\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_ret\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n@eq_ret:\\n\\tsubleq @0 @0 @ret\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n\\tsubleq @has_rpb @has_rpb\\n\\tsubleq @has_rpb @rp\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_nrp\\n\\tsubleq @0 @0 @eq @has_ret:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @0 @0 @ret\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n@has_nrp: .data -@has_ret\\n@has_rpb: .data 0\\n\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n;@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n;@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n;@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n\"},{\"name\":\"Untitled (1)\",\"code\":\"@start:\\n\\tsubleq @loop_b_i @loop_b_i\\n\\tsubleq @loop_b_i @arr_b_np\\n@read_a:\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_a_np\\n\\tsubleq @0 @0 @read_arr\\n@read_b:\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_b_np\\n\\tsubleq @t @t\\n\\tsubleq @t @n_1\\n\\tsubleq @0 @0 @read_arr\\n@loop_b:\\n\\tsubleq @a @a\\n\\tsubleq @a @loop_b_i:255\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @xa @xa\\n\\tsubleq @xa @a\\n\\tsubleq @xa @0 @restart\\n\\t\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @0 @0 @has @has_back:\\n\\n\\tsubleq @a @a\\n\\tsubleq @a @xr\\n\\tsubleq @OUT @a\\n@loop_b_cont:\\n\\tsubleq @loop_b_i @n_1\\n\\tsubleq @0 @0 @loop_b\\t\\n@restart:\\n\\tsubleq @reset_c @reset_c\\n\\tsubleq @reset_c @12\\n\\tsubleq @clear_i @clear_i\\n\\tsubleq @clear_i @arr_a_np\\n\\tsubleq @clear_i+1 @clear_i+1\\n\\tsubleq @clear_i+1 @arr_a_np\\n@reset_loop:\\n\\tsubleq @clear_i:0 @clear_i\\n\\tsubleq @clear_i @n_1\\n\\tsubleq @clear_i+1 @n_1\\n\\tsubleq @reset_c @n_1 @reset_loop\\n\\n\\tsubleq @0 @0 @start\\n\\n\\n@arr_a: .data 0 0 0 0 0 0\\n@arr_b: .data 0 0 0 0 0 0\\n@t: .data 0\\n@reset_c: .data 0\\n@arr_a_np: .data -@arr_a\\n@arr_b_np: .data -@arr_b\\n\\n; STD\\n\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\tsubleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @t @0 @read_b\\n\\tsubleq @0 @0 @loop_b\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_back\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_back\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n\\tsubleq @0 @0 @eq_back\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @0 @0 @eq @eq_back:\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @0 @0 @has_back\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n;@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n;@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n;@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n@12: .data 12\"}],\"currentSolutionName\":\"Untitled (1)\",\"solutionCycles\":562,\"solutionBytes\":236}","sic1_steamApi":"{\"leaderboardQueue\":{\"limiter\":{\"rate\":{\"count\":10,\"periodMS\":600000},\"history\":[\"2024-09-13T19:37:53.639Z\",\"2024-09-13T19:39:56.365Z\"]},\"queue\":[{\"task\":{\"id\":\"Sequence Cardinality_cycles\",\"score\":27,\"details\":[253,14,6,13,15,0,254,13,9,13,13,0,0,0,0,1],\"retryCount\":3},\"start\":\"2024-09-13T23:42:59.755Z\"},{\"task\":{\"id\":\"Sequence Cardinality_bytes\",\"score\":17,\"details\":[253,14,6,13,15,0,254,13,9,13,13,0,0,0,0,1],\"retryCount\":3},\"start\":\"2024-09-13T23:42:59.755Z\"},{\"task\":{\"id\":\"Number to Sequence_cycles\",\"score\":64,\"details\":[21,253,3,21,23,12,254,22,9,21,21,0,254,23,15,21,23,12,21,21,6,0,0,255,1],\"retryCount\":3},\"start\":\"2024-09-13T23:48:04.993Z\"},{\"task\":{\"id\":\"Number to Sequence_bytes\",\"score\":26,\"details\":[21,253,3,21,23,12,254,22,9,21,21,0,254,23,15,21,23,12,21,21,6,0,0,255,1],\"retryCount\":3},\"start\":\"2024-09-13T23:48:04.993Z\"},{\"task\":{\"id\":\"Self-Modifying Code_cycles\",\"score\":46,\"details\":[12,0,3,254,12,6,1,13,9,12,12,0,0,255],\"retryCount\":3},\"start\":\"2024-09-13T23:52:59.761Z\"},{\"task\":{\"id\":\"Self-Modifying Code_bytes\",\"score\":15,\"details\":[12,0,3,254,12,6,1,13,9,12,12,0,0,255],\"retryCount\":3},\"start\":\"2024-09-13T23:57:04.988Z\"},{\"task\":{\"id\":\"Stack Memory_cycles\",\"score\":19,\"details\":[32,253,3,30,27,12,0,28,9,29,29,0,29,0,15,19,29,18,254,0,21,19,27,24,29,29,18,1,255,0,3,32,0],\"retryCount\":3},\"start\":\"2024-09-13T23:58:04.997Z\"},{\"task\":{\"id\":\"Stack Memory_bytes\",\"score\":36,\"details\":[32,253,3,30,27,12,0,28,9,29,29,0,29,0,15,19,29,18,254,0,21,19,27,24,29,29,18,1,255,0,3,32,0],\"retryCount\":3},\"start\":\"2024-09-13T23:58:05.991Z\"}]}}","sic1_Puzzle_Strings":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":40,\"solutionBytes\":26,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @OUT, @c:@msg\\nsubleq @c, @n_1\\nsubleq @tmp, @tmp, @loop\\n\\n@n_1: .data -1\\n@msg: .data -\\\"Hello, world!\\\"\\n@tmp: .data 0\\n\",\"solutionCycles\":40,\"solutionBytes\":26}],\"currentSolutionName\":\"Untitled\"}","sic1_":"{\"userId\":\"exwrbenroyunzgo\",\"name\":\"COOKIEEEEEEEEEEEEEEEE\",\"introCompleted\":true,\"solvedCount\":22,\"currentPuzzle\":\"Number to Sequence\",\"generation\":3,\"inbox\":[{\"id\":\"s0_0\",\"read\":true},{\"id\":\"s0_1\",\"read\":true},{\"id\":\"s0_2\",\"read\":true},{\"id\":\"Subleq Instruction and Output\",\"read\":true},{\"id\":\"s1_0\",\"read\":true},{\"id\":\"Data Directive and Looping\",\"read\":true},{\"id\":\"s2_0\",\"read\":true},{\"id\":\"s2_1\",\"read\":true},{\"id\":\"First Assessment\",\"read\":true},{\"id\":\"s3_0\",\"read\":true},{\"id\":\"s3_1\",\"read\":true},{\"id\":\"Addition\",\"read\":true},{\"id\":\"s4_0\",\"read\":true},{\"id\":\"s4_1\",\"read\":true},{\"id\":\"Subtraction\",\"read\":true},{\"id\":\"s5_0\",\"read\":true},{\"id\":\"Sign Function\",\"read\":true},{\"id\":\"s6_0\",\"read\":true},{\"id\":\"Multiplication\",\"read\":true},{\"id\":\"s7_0\",\"read\":true},{\"id\":\"s7_1\",\"read\":true},{\"id\":\"Division\",\"read\":true},{\"id\":\"s8_0\",\"read\":true},{\"id\":\"Sequence Sum\",\"read\":true},{\"id\":\"s9_0\",\"read\":true},{\"id\":\"Sequence Cardinality\",\"read\":true},{\"id\":\"s10_0\",\"read\":true},{\"id\":\"Number to Sequence\",\"read\":true},{\"id\":\"s11_0\",\"read\":true},{\"id\":\"Self-Modifying Code\",\"read\":true},{\"id\":\"s12_0\",\"read\":true},{\"id\":\"Stack Memory\",\"read\":true},{\"id\":\"s13_0\",\"read\":true},{\"id\":\"Reverse Sequence\",\"read\":true},{\"id\":\"s14_0\",\"read\":true},{\"id\":\"Interleave\",\"read\":true},{\"id\":\"s15_0\",\"read\":true},{\"id\":\"Indicator Function\",\"read\":true},{\"id\":\"s16_0\",\"read\":true},{\"id\":\"Sort\",\"read\":true},{\"id\":\"s17_0\",\"read\":true},{\"id\":\"Mode\",\"read\":true},{\"id\":\"s18_0\",\"read\":true},{\"id\":\"Characters\",\"read\":true},{\"id\":\"s19_0\",\"read\":true},{\"id\":\"Decimal Digits\",\"read\":true},{\"id\":\"s20_0\",\"read\":true},{\"id\":\"Uppercase\",\"read\":true},{\"id\":\"s21_0\",\"read\":true},{\"id\":\"Strings\",\"read\":true},{\"id\":\"s22_0\",\"read\":true},{\"id\":\"s22_1\",\"read\":true}],\"colorScheme\":\"White on Black\",\"tabInsertMode\":true}","sic1__avoision":"{\"score\":251}","sic1_Puzzle_Addition":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":19,\"solutionBytes\":15,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @b @b\\nsubleq @a @IN\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @b\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":49,\"solutionBytes\":34},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":19,\"solutionBytes\":15},{\"name\":\"Untitled (2)\",\"code\":\"; Read two numbers and output their sum. Repeat.\\n;\\n; Below is the solution to the previous task. You will need to add\\n; additional code to perform addition of two inputs (instead of\\n; passing through a single input):\\n\\n.data 12, -3, 3, 12, -3, 6, -2, 12, 9, 12, 12\",\"solutionCycles\":19,\"solutionBytes\":15}],\"currentSolutionName\":\"Untitled (2)\"}","sic1_Puzzle_Decimal Digits":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":11,\"solutionBytes\":16,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @off\\nsubleq @OUT @a @loop\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@off: .data -48\\n\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Tokenizer":"{\"unlocked\":true,\"viewed\":true,\"solved\":false,\"solutions\":[{\"name\":\"Untitled\",\"code\":null}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Uppercase":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":61,\"solutionBytes\":43,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @lo_lim @skip\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @hi_lim @cont\\nsubleq @b @b @skip\\n@cont:\\nsubleq @a @off\\nsubleq @OUT @a @loop\\nsubleq @a @a @loop\\n@skip:\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@off: .data -32\\n@lo_lim: .data 96\\n@hi_lim: .data 122\",\"solutionCycles\":61,\"solutionBytes\":43}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Subleq Instruction and Output":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":1,\"solutionBytes\":5,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; The Single Instruction Computer Mark 1 (SIC-1) is an 8-bit computer\\n; with 256 bytes of memory. Programs for the SIC-1 are written in\\n; SIC-1 Assembly Language.\\n;\\n; Each instruction is 3 bytes, specified as follows:\\n;\\n;   subleq <A> <B> [<C>]\\n;\\n; A, B, and C are memory addresses (0 - 255) or labels.\\n;\\n; \\\"subleq\\\" subtracts the value at address B from the value at address\\n; A and stores the result at address A (i.e. mem[A] ← mem[A] -\\n; mem[B]).\\n;\\n; If the result is <= 0, execution branches to address C.\\n;\\n; Note that if C is not specified, the address of the next\\n; instruction is automatically added by the assembler (in effect,\\n; this means that taking the branch is no different from advancing to\\n; the next instruction).\\n;\\n; For convenience, addresses can be specified using labels. The\\n; following predefined labels are always available:\\n;\\n;   @MAX (252): Maximum user-modifiable address\\n;   @IN (253): Reads a value from input (writes are ignored)\\n;   @OUT (254): Writes a result to output (reads as zero)\\n;   @HALT (255): Terminates the program when accessed\\n;\\n; Note: any text following a semicolon is considered a comment.\\n; Comments are ignored by the assembler.\\n; \\n; Below is a very simple SIC-1 program that negates one input value\\n; and writes it out.\\n;\\n; E.g. if the input value from @IN is 3, it subtracts 3 from @OUT\\n; (which reads as zero), and the result of 0 - 3 = -3 is written out.\\n\\nsubleq @OUT @IN\\n\\n; Use the \\\"Compile/Step\\\" (Ctrl+.) and \\\"Run\\\" (Ctrl+Enter) buttons to\\n; execute the program until all expected outputs have been\\n; successfully written out (see the \\\"In\\\"/\\\"Expected\\\"/\\\"Out\\\" table to\\n; the left).\\n\",\"solutionCycles\":1,\"solutionBytes\":5},{\"name\":\"Untitled (1)\",\"code\":\"; The Single Instruction Computer Mark 1 (SIC-1) is an 8-bit computer\\n; with 256 bytes of memory. Programs for the SIC-1 are written in\\n; SIC-1 Assembly Language.\\n;\\n; Each instruction is 3 bytes, specified as follows:\\n;\\n;   subleq <A> <B> [<C>]\\n;\\n; A, B, and C are memory addresses (0 - 255) or labels.\\n;\\n; \\\"subleq\\\" subtracts the value at address B from the value at address\\n; A and stores the result at address A (i.e. mem[A] ← mem[A] -\\n; mem[B]).\\n;\\n; If the result is <= 0, execution branches to address C.\\n;\\n; Note that if C is not specified, the address of the next\\n; instruction is automatically added by the assembler (in effect,\\n; this means that taking the branch is no different from advancing to\\n; the next instruction).\\n;\\n; For convenience, addresses can be specified using labels. The\\n; following predefined labels are always available:\\n;\\n;   @MAX (252): Maximum user-modifiable address\\n;   @IN (253): Reads a value from input (writes are ignored)\\n;   @OUT (254): Writes a result to output (reads as zero)\\n;   @HALT (255): Terminates the program when accessed\\n;\\n; Note: any text following a semicolon is considered a comment.\\n; Comments are ignored by the assembler.\\n; \\n; Below is a very simple SIC-1 program that negates one input value\\n; and writes it out.\\n;\\n; E.g. if the input value from @IN is 3, it subtracts 3 from @OUT\\n; (which reads as zero), and the result of 0 - 3 = -3 is written out.\\n\\n;subleq @OUT, @IN\\n.data -2 -3 3\\n\\n; Use the \\\"Compile/Step\\\" (Ctrl+.) and \\\"Run\\\" (Ctrl+Enter) buttons to\\n; execute the program until all expected outputs have been\\n; successfully written out (see the \\\"In\\\"/\\\"Expected\\\"/\\\"Out\\\" table to\\n; the left).\\n\",\"solutionCycles\":1,\"solutionBytes\":5}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Multiplication":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":96,\"solutionBytes\":46,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Read two nonnegative numbers and output the resulting (nonnegative)\\n; product. Repeat.\\n\\n@loop:\\nsubleq @a @IN\\nsubleq @c @IN\\nsubleq @b @c @res\\nsubleq @c @c\\n\\n@acc:\\nsubleq @n @a\\nsubleq @b @1 @res\\nsubleq @c @c @acc\\n\\n@res:\\nsubleq @c @c\\nsubleq @c @n\\nsubleq @OUT @c\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @n @n @loop \\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@n: .data 0\\n@0: .data 0\\n@1: .data 1\",\"solutionCycles\":96,\"solutionBytes\":46}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Subtraction":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":29,\"solutionBytes\":22,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @IN\\nsubleq @a @b\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":29,\"solutionBytes\":22}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Characters":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":2,\"solutionBytes\":9,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"subleq @OUT, @s\\nsubleq @OUT, @s+1\\n\\n@s: .data -'H' -'i'\\n\\n\",\"solutionCycles\":2,\"solutionBytes\":9}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Sequence Sum":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":87,\"solutionBytes\":32,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @endseq\\n\\nsubleq @acc @b @inner\\n\\n@endseq:\\nsubleq @OUT @acc\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\",\"solutionCycles\":115,\"solutionBytes\":33},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @acc @a\\nsubleq @a @n1 @cont\\nsubleq @a @a @endseq\\n\\n@cont:\\nsubleq @a @a @inner\\n\\n@endseq:\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":87,\"solutionBytes\":32},{\"name\":\"Untitled (2)\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @acc @a\\nsubleq @a @n1 @cont\\n\\n@endseq:\\nsubleq @a @a\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@cont:\\nsubleq @a @a @inner\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\"}],\"currentSolutionName\":\"Untitled (2)\"}","sic1_Puzzle_Sign Function":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":30,\"solutionBytes\":33,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @lez\\nsubleq @OUT @n1\\nsubleq @a @a @loop\\n\\n@lez:\\nsubleq @a @a\\nsubleq @a @b @ez\\nsubleq @a @a\\nsubleq @OUT @1 @loop\\n\\n@ez:\\nsubleq @OUT @a @loop\\n\\n@gz:\\nsubleq @OUT @n1\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":42,\"solutionBytes\":36},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @a @IN @gez\\nsubleq @a @a\\nsubleq @OUT @1 @loop\\n\\n@gez:\\nsubleq @b @a @ez\\nsubleq @a @a\\nsubleq @b @b\\nsubleq @OUT @n1 @loop\\nsubleq @a @a @loop\\n\\n@ez:\\nsubleq @OUT @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":30,\"solutionBytes\":33}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Sequence Cardinality":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":27,\"solutionBytes\":17,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @a @n1 @cont\\n\\n@endseq:\\nsubleq @a @a\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@cont:\\nsubleq @acc @n1\\nsubleq @a @a @inner\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":59,\"solutionBytes\":32},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\n\\n@inner:\\nsubleq @IN @0 @endseq\\n\\n@cont:\\nsubleq @acc @1 @inner\\n\\n@endseq:\\nsubleq @OUT @acc\\nsubleq @acc @acc @loop\\n\\n@a: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@1: .data 1\",\"solutionCycles\":27,\"solutionBytes\":17}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Interleave":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@read1:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @read2\\nsubleq 128 @b ; PATCH\\n\\nsubleq @read1+15 @n1\\nsubleq @a @a @read1\\n\\n@read2:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @interl\\nsubleq 144 @b ; PATCH\\n\\nsubleq @read2+15 @n1\\nsubleq @a @a @read2\\n\\n@interl:\\nsubleq @a @a\\nsubleq @a 128 @done ; PATCH\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @OUT @b\\n\\nsubleq @a @a\\nsubleq @a 144 @done ; PATCH\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @OUT @b\\n\\nsubleq @interl+4 @n1\\nsubleq @interl+19 @n1\\nsubleq @b @b @interl\\n\\n@done:\\nsubleq @OUT @0 @read1\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":329,\"solutionBytes\":117}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":329,\"solutionBytes\":117}","sic1_Puzzle_Sort":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\n\\tsubleq @reset_c @reset_c\\n\\tsubleq @reset_c @12\\n\\tsubleq @reset_i @reset_i\\n\\tsubleq @reset_i @arr_np\\n\\tsubleq @reset_i+1 @reset_i+1\\n\\tsubleq @reset_i+1 @arr_np\\n@reset_arr:\\n\\tsubleq @reset_i:0 @reset_i\\n\\tsubleq @reset_i @n_1\\n\\tsubleq @reset_i+1 @n_1\\n\\tsubleq @reset_c @n_1 @reset_arr\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_np\\n\\tsubleq @a @a @read @read_arr_back:\\n@sort:\\n\\tsubleq @i @i\\n\\tsubleq @i @arr_np\\n\\tsubleq @swap_i @swap_i\\n\\tsubleq @swap_i @arr_np\\n\\tsubleq @clear_i @clear_i\\n\\tsubleq @clear_i @arr_np\\n\\tsubleq @clear_i+1 @clear_i+1\\n\\tsubleq @clear_i+1 @arr_np\\n\\tsubleq @j @j\\n\\tsubleq @j @arr_np\\n\\tsubleq @j @n_1\\n\\tsubleq @swap_j @swap_j\\n\\tsubleq @swap_j @arr_np\\n\\tsubleq @swap_j @n_1\\n\\tsubleq @clear_j @clear_j\\n\\tsubleq @clear_j @arr_np\\n\\tsubleq @clear_j @n_1\\n\\tsubleq @clear_j+1 @clear_j+1\\n\\tsubleq @clear_j+1 @arr_np\\n\\tsubleq @clear_j+1 @n_1\\n@sort_inner:\\n\\tsubleq @a @a\\n\\tsubleq @a @i:0\\n\\tsubleq @d @d\\n\\tsubleq @d @a\\n\\tsubleq @c @c\\n\\tsubleq @c @d\\n\\n\\tsubleq @b @b\\n\\tsubleq @b @j:0\\n\\tsubleq @d @d\\n\\tsubleq @d @b\\n\\tsubleq @d @0 @pass_complete\\n\\n\\tsubleq @c @n_1\\n\\tsubleq @c @b @swap\\n\\tsubleq @print @0 @sort_cont\\n\\tsubleq @OUT @a\\n@sort_cont:\\n\\tsubleq @i @n_1\\n\\tsubleq @j @n_1\\n\\tsubleq @swap_i @n_1\\n\\tsubleq @swap_j @n_1\\n\\tsubleq @clear_i @n_1\\n\\tsubleq @clear_i+1 @n_1\\n\\tsubleq @clear_j @n_1\\n\\tsubleq @clear_j+1 @n_1\\n\\tsubleq @0 @0 @sort_inner\\n@swap:\\n\\tsubleq @dirty @n_1\\n\\tsubleq @clear_i:0 @clear_i\\n\\tsubleq @clear_j:0 @clear_j\\n\\tsubleq @swap_i:0 @b\\n\\tsubleq @swap_j:0 @a @sort_cont\\n@pass_complete:\\n\\tsubleq @print @0 @no_print\\n\\tsubleq @OUT @a\\n\\tsubleq @OUT @0\\n@no_print:\\n\\tsubleq @dirty @0 @sorted\\n\\tsubleq @dirty @dirty @sort\\n@sorted:\\n\\tsubleq @print @0 @start_print\\n\\tsubleq @print @1\\n\\tsubleq @0 @0 @loop\\n@start_print:\\n\\tsubleq @print @n_1\\n\\tsubleq @0 @0 @sort\\n@read:\\n\\tsubleq @a @IN\\n@write:\\n\\tsubleq @read_arr_i:255 @a @write_done\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @a @a @read\\n@write_done:\\n\\tsubleq @0 @0 @read_arr_back\\n\\n@arr_np: .data -@arr\\n@current: .data 0\\n@dirty: .data 0\\n@print: .data 0\\n@reset_c: .data 0\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n; consts\\n@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n@12: .data 8\\n\\n@arr: .data 0 0 0 0 0 0 0 0 1\",\"solutionCycles\":1670,\"solutionBytes\":254}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":1670,\"solutionBytes\":254}","sic1_Puzzle_Print Decimal":"{\"unlocked\":true,\"viewed\":false,\"solved\":false,\"solutions\":[{\"name\":\"Untitled\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Division":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @a @a\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @a @IN\\nsubleq @dv @a\\nsubleq @dr @IN\\n\\n@l2:\\nsubleq @dv @0 @res\\nsubleq @dv @1\\nsubleq @r @n1\\n\\nsubleq @a @a\\nsubleq @a @dr\\nsubleq @a @r @nextq\\nsubleq @a @a @l2\\n\\n@nextq:\\nsubleq @r @r\\nsubleq @q @n1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @e @e\\nsubleq @e @q\\nsubleq @OUT @e\\nsubleq @e @e\\nsubleq @e @r\\nsubleq @OUT @e\\nsubleq @r @r @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n@r: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":755,\"solutionBytes\":83},{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @a @a\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @a @IN\\nsubleq @dv @a\\nsubleq @b @b\\nsubleq @b @IN\\nsubleq @dr @b\\n\\n@l2:\\nsubleq @a @a\\nsubleq @a @dr\\nsubleq @b @b\\nsubleq @b @dv\\nsubleq @b @a @nextq\\nsubleq @a @a @res\\n\\n@nextq:\\nsubleq @dv @dr\\nsubleq @q @n1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @a @a\\nsubleq @a @dv\\nsubleq @a @a\\nsubleq @a @q\\nsubleq @OUT @a\\n\\nsubleq @a @a\\nsubleq @a @dv\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n@r: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":247,\"solutionBytes\":89},{\"name\":\"Untitled (2)\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @dv @IN\\nsubleq @dr @IN\\n\\n@l2:\\nsubleq @a @dr\\nsubleq @b @b\\nsubleq @b @n1\\nsubleq @b @dv\\nsubleq @b @a @res\\nsubleq @a @a @nextq\\n\\n@nextq:\\nsubleq @dv @dr\\nsubleq @q @1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @OUT @q\\nsubleq @OUT @dv\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":222,\"solutionBytes\":60}],\"currentSolutionName\":\"Untitled (3)\",\"solutionCycles\":222,\"solutionBytes\":60}"}