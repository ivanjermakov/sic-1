{"sic1_Puzzle_Stack Memory":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":19,\"solutionBytes\":36,\"solutions\":[{\"name\":\"Untitled\",\"code\":null,\"solutionCycles\":19,\"solutionBytes\":36}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Number to Sequence":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":64,\"solutionBytes\":26,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @n @IN\\nsubleq @n @n1 @inner\\n\\n@done:\\nsubleq @OUT @0\\nsubleq @n @n @loop\\n\\n@inner:\\nsubleq @OUT @n1\\nsubleq @n @n1 @inner\\nsubleq @n @n @done\\n\\n@n: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\\n@1: .data 1\",\"solutionCycles\":64,\"solutionBytes\":26}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Self-Modifying Code":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":46,\"solutionBytes\":15,\"solutions\":[{\"name\":\"Untitled\",\"code\":null}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Calculator":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @pint_ret @pint_ret\\nsubleq @pint_ret @b1_np\\nsubleq @0 @0 @pint @b1:\\nsubleq @f @f\\nsubleq @f @c\\n\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @h @h\\nsubleq @h @a\\nsubleq @a @IN\\n\\nsubleq @pint_ret @pint_ret\\nsubleq @pint_ret @b3_np\\nsubleq @0 @0 @pint @b3:\\nsubleq @g @g\\nsubleq @g @c\\n\\nsubleq @h @c_star @calc_mult\\nsubleq @h @1 @calc_add\\n\\n@calc_sub:\\nsubleq @f @g\\nsubleq @a @a\\nsubleq @a @f\\nsubleq @OUT @a\\nsubleq @0 @0 @loop\\n\\n@calc_mult:\\nsubleq @c @c\\nsubleq @c @f\\nsubleq @a @a\\nsubleq @a @c\\n\\nsubleq @c @c\\nsubleq @c @g\\nsubleq @b @b\\nsubleq @b @c\\n\\nsubleq @nmul_ret @nmul_ret\\nsubleq @nmul_ret @b4_np\\nsubleq @0 @0 @nmul @b4:\\nsubleq @OUT @c\\nsubleq @0 @0 @loop\\n\\n@calc_add:\\nsubleq @a @a\\nsubleq @a @f\\nsubleq @a @g\\nsubleq @OUT @a\\nsubleq @0 @0 @loop\\n\\n; read chars from @IN until invalid digit, write negated parsed int to @c\\n@pint:\\nsubleq @d @d\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @n_1\\nsubleq @b @atoi_off @pint_done\\nsubleq @b @1\\nsubleq @e @n_atoi_off\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @nmul_ret @nmul_ret\\nsubleq @nmul_ret @b2_np\\nsubleq @0 @0 @nmul @b2:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @0 @0 @pint_ret:0\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret:0\\n\\n@b1_np: .data -@b1\\n@b2_np: .data -@b2\\n@b3_np: .data -@b3\\n@b4_np: .data -@b4\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n@h: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@c_star: .data '*'\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@n_3: .data -3\\n@n_10: .data -10\",\"solutionCycles\":381,\"solutionBytes\":234}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":381,\"solutionBytes\":234}","sic1_Puzzle_Parse Data Directives":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\n\\nsubleq @pint_ret @pint_ret\\nsubleq @pint_ret @b1_np\\nsubleq @0 @0 @pint @b1:\\nsubleq @OUT @c\\nsubleq @0 @0 @loop\\n\\n; read chars from @IN until invalid digit, write negated parsed int to @c\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @10 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @nmul_ret @nmul_ret\\nsubleq @nmul_ret @b2_np\\nsubleq @0 @0 @nmul @b2:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret:0\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret:0\\n\\n@b1_np: .data -@b1\\n@b2_np: .data -@b2\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n@h: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@c_star: .data '*'\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@n_3: .data -3\\n@n_10: .data -10\\n@10: .data 10\\n@n_47: .data -47\",\"solutionCycles\":184,\"solutionBytes\":194}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":184,\"solutionBytes\":194}","sic1_Puzzle_Sandbox Mode":"{\"unlocked\":true,\"viewed\":true,\"solved\":false,\"solutions\":[{\"name\":\"selfdestruct\",\"code\":\".data -3\\n\",\"customInput\":\"-3\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"},{\"name\":\"ret\",\"code\":\"@start:\\nsubleq @rp @rp\\nsubleq @rp @r1\\nsubleq @0 @0 @proc_foo\\n\\nsubleq @rp @rp\\nsubleq @rp @r2\\nsubleq @0 @0 @proc_foo\\n\\nsubleq @0 @0 @HALT\\n\\n; arbitrary procedure that will jump to rp once finished\\n@proc_foo:\\nsubleq @OUT @0\\nsubleq @a @a @ret\\n\\n@ret:\\nsubleq @a @a @rp:255 ; PATCH\\n\\n; return consts\\n@r1: .data -9\\n@r2: .data -18\\n\\n; tmp registers\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n@1: .data 1\\n@n1: .data -1\\n@0: .data 0\",\"customInput\":\"1 1 67 9\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"},{\"name\":\"std\",\"code\":\"@start:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @n_arr_p\\n\\tsubleq @0 @0 @read_arr @start_ret:\\n\\tsubleq @OUT @xr\\n@start_loop:\\t\\n\\tsubleq @0 @0 @start\\n\\t\\n@start_nrp: .data -@start_ret\\n\\n\\n@arr: .data 0, 0, 0, 0, 0\\n@n_arr_p: .data -@arr\\n\\n; STD\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i and\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\t!subleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @0 @0 @ret\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_ret\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_ret\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n@eq_ret:\\n\\tsubleq @0 @0 @ret\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n\\tsubleq @has_rpb @has_rpb\\n\\tsubleq @has_rpb @rp\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_nrp\\n\\tsubleq @0 @0 @eq @has_ret:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @0 @0 @ret\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n@has_nrp: .data -@has_ret\\n@has_rpb: .data 0\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n\",\"customInput\":\"3 6 0\",\"customInputFormat\":\"numbers\",\"customOutputFormat\":\"numbers\"},{\"name\":\"self-hosting close\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @4\\n@pfx_loop:\\nsubleq @a @IN\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @10 @subleq_stmt\\nsubleq @a @a @data_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@subleq_stmt:\\nsubleq @a @IN\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @a @IN\\nsubleq @g @g\\nsubleq @g @2 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @b\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @0 @0 @nmul @nmul_ret:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret\\n\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@4: .data 4\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@n_47: .data -47\\n\",\"customInput\":\"\\\"subleq 10 9 3\\\\n.data -9\\\"\",\"customInputFormat\":\"strings\",\"customOutputFormat\":\"numbers\"},{\"name\":\"self-hosting\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @4\\n@pfx_loop:\\nsubleq @a @IN\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @10 @subleq_stmt\\nsubleq @a @a @data_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@subleq_stmt:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @0 @comp_done\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @a @IN\\nsubleq @g @g\\nsubleq @g @2 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @0 @0 @nmul @nmul_ret:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret\\n\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@4: .data 4\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@n_47: .data -47\\n\",\"customInput\":\"\\\"subleq 10 9 3\\\\n.data -9\\\"\",\"customInputFormat\":\"strings\",\"customOutputFormat\":\"numbers\"},{\"name\":\"Untitled\",\"code\":\"subleq 254 0 3\\nsubleq 1 12 6\\nsubleq 14 12 0\\nsubleq 15 15 255\\n.data -1\\n.data 1\\n.data -11\\n.data 0\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Data Directive and Looping":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":3,\"solutionBytes\":5,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Custom labels are defined by putting \\\"@name: \\\" at the beginning of\\n; a line, e.g.:\\n;\\n;   @loop: subleq 1, 2\\n;\\n; In addition to \\\"subleq\\\", there is an assembler directive \\\".data\\\"\\n; that sets a byte of memory to a value at compile time (note: this\\n; is not an instruction!):\\n;\\n;   .data <X>\\n;\\n; X is a signed byte between -128 and 127 (inclusive).\\n;\\n; Combining labels and the \\\".data\\\" directive allows you to develop a\\n; system of constants and variables. For example, here a byte is set\\n; to zero, and the label @zero points to that value:\\n;\\n;   @zero: .data 0\\n;\\n; Note that, while a program is executing, you can view the current\\n; value of each variable in the variable table on the right (under\\n; the memory table).\\n;\\n; Variables can be used for implementing an unconditional jump:\\n;\\n;   subleq @zero, @zero, @next\\n;\\n; This will set @zero to @zero - @zero (still zero) and, since the\\n; result is always <= 0, execution branches to @next.\\n;\\n; Below is an updated negation program that repeatedly negates input\\n; values and writes them out in a loop.\\n\\n@loop:\\nsubleq @OUT @IN @loop\\n\\n\",\"solutionCycles\":3,\"solutionBytes\":5}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_First Assessment":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":8,\"solutionBytes\":12,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Now that you understand the \\\"subleq\\\" instruction, the \\\".data\\\"\\n; directive, and labels, you should be able to read values from input\\n; and write the exact same values out, by negating the value twice.\\n;\\n; Below is an almost complete solution. You will need to replace\\n; instances of \\\"???\\\". Hint: use a label that points to a storage\\n; location for a (negated) value.\\n\\n@loop:\\nsubleq @tmp, @IN\\nsubleq @OUT, @tmp\\nsubleq @tmp, @tmp, @loop  ; Reset @tmp to zero, and jump to @loop\\n\\n@tmp: .data 0\\n\",\"solutionCycles\":8,\"solutionBytes\":12}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Parse Decimal":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\n@reset:\\nsubleq @arr @arr\\nsubleq @arr+1 @arr+1\\nsubleq @arr+2 @arr+2\\n\\nsubleq @w_i @w_i\\nsubleq @r_i @r_i\\nsubleq @r_j @r_j\\nsubleq @r_k @r_k\\n\\nsubleq @w_i @arr_np\\nsubleq @r_i @arr_np\\nsubleq @r_j @arr_np1\\nsubleq @r_k @arr_np2\\n\\n@write_loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @write_done\\nsubleq @w_i:255 @b\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\nsubleq @r_k @n_1\\nsubleq @a @a @write_loop\\n\\n@write_done:\\n;TODO: refactor\\nsubleq @w_i @1\\nsubleq @r_i @1\\nsubleq @r_j @1\\nsubleq @r_k @1\\n\\n@assemble:\\nsubleq @c @c\\n\\n@d1:\\nsubleq @a @a\\nsubleq @a @r_i:255\\nsubleq @a @atoi_off\\nsubleq @c @a\\n\\n@d2:\\nsubleq @a @a\\nsubleq @a @r_j:255\\nsubleq @d @d\\nsubleq @d @a\\nsubleq @a @0 @print\\nsubleq @a @atoi_off\\n\\nsubleq @b @b\\nsubleq @b @n_10\\n\\n@d2_loop:\\nsubleq @c @a\\nsubleq @b @1 @d3\\nsubleq @0 @0 @d2_loop\\n\\n@d3:\\nsubleq @a @a\\nsubleq @a @r_k:255\\nsubleq @a @0 @print\\n\\n;subleq @b @b\\n;subleq @b @n_100\\n;@d3_loop:\\n;subleq @c @a\\n;subleq @b @1 @print\\n;subleq @0 @0 @d3_loop\\n;opt: since 3rd digit can max be 1, we only need to do @c-=100\\nsubleq @c @100\\n\\n@print:\\nsubleq @OUT @c\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n@atoi_off: .data 48\\n@1: .data 1\\n@n_1: .data -1\\n@n_10: .data -10\\n@100: .data 100\\n@arr_np: .data -@arr\\n@arr_np1: .data -@arr+1\\n@arr_np2: .data -@arr+2\\n@0: .data 0\\n@arr: .data 0 0 0\",\"solutionCycles\":212,\"solutionBytes\":155},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\n@reset:\\nsubleq @arr @arr\\nsubleq @arr+1 @arr+1\\nsubleq @arr+2 @arr+2\\n\\nsubleq @w_i @w_i\\nsubleq @r_i @r_i\\nsubleq @r_j @r_j\\nsubleq @r_k @r_k\\n\\nsubleq @w_i @arr_np1\\nsubleq @r_i @arr_np1\\nsubleq @r_j @arr_np2\\nsubleq @r_k @arr_np3\\n\\n@write_loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @assemble\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\nsubleq @r_k @n_1\\nsubleq @w_i:255 @b\\n\\nsubleq @a @a @write_loop\\n\\n@assemble:\\nsubleq @c @c\\n\\n@d1:\\nsubleq @a @a\\nsubleq @a @r_i:255\\nsubleq @a @atoi_off\\nsubleq @c @a\\n\\n@d2:\\nsubleq @a @a\\nsubleq @a @r_j:255\\nsubleq @d @d\\nsubleq @d @a\\nsubleq @a @0 @print\\nsubleq @a @atoi_off\\n\\nsubleq @b @b\\nsubleq @b @n_10\\n\\n@d2_loop:\\nsubleq @c @a\\nsubleq @b @1 @d3\\nsubleq @0 @0 @d2_loop\\n\\n@d3:\\nsubleq @a @a\\nsubleq @a @r_k:255\\nsubleq @a @0 @print\\n\\n;opt: since 3rd digit can max be 1, we only need to do @c-=100\\nsubleq @c @100\\n\\n@print:\\nsubleq @OUT @c\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n@atoi_off: .data 48\\n@1: .data 1\\n@n_1: .data -1\\n@n_10: .data -10\\n@100: .data 100\\n@arr_np: .data -@arr\\n@arr_np1: .data -@arr+1\\n@arr_np2: .data -@arr+2\\n@arr_np3: .data -@arr+3\\n@0: .data 0\\n@arr: .data 0 0 0\",\"solutionCycles\":200,\"solutionBytes\":143},{\"name\":\"Untitled (2)\",\"code\":\"@loop:\\n@reset:\\nsubleq @arr @arr\\nsubleq @arr+1 @arr+1\\nsubleq @arr+2 @arr+2\\n\\nsubleq @w_i @w_i\\nsubleq @r_i @r_i\\nsubleq @r_j @r_j\\nsubleq @r_k @r_k\\n\\nsubleq @w_i @arr_np1\\nsubleq @r_i @arr_np1\\nsubleq @r_j @arr_np2\\nsubleq @r_k @arr_np3\\n\\n@write_loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @assemble\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\nsubleq @r_k @n_1\\nsubleq @w_i:255 @b\\n\\nsubleq @a @a @write_loop\\n\\n@assemble:\\nsubleq @c @c\\n\\n@d1:\\nsubleq @a @a\\nsubleq @a @r_i:255\\nsubleq @a @atoi_off\\nsubleq @c @a\\n\\n@d2:\\nsubleq @a @a\\nsubleq @a @r_j:255\\nsubleq @d @d\\nsubleq @d @a\\nsubleq @a @0 @print\\nsubleq @a @atoi_off\\n\\nsubleq @b @b\\nsubleq @b @n_10\\n\\n@d2_loop:\\nsubleq @c @a\\nsubleq @b @1 @d3\\nsubleq @0 @0 @d2_loop\\n\\n@d3:\\nsubleq @a @a\\nsubleq @a @r_k:255\\nsubleq @a @0 @print\\n\\n;opt: since 3rd digit can max be 1, we only need to do @c-=100\\nsubleq @c @100\\n\\n@print:\\nsubleq @OUT @c\\nsubleq @0 @0 @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n@atoi_off: .data 48\\n@1: .data 1\\n@n_1: .data -1\\n@n_10: .data -10\\n@100: .data 100\\n@arr_np: .data -@arr\\n@arr_np1: .data -@arr+1\\n@arr_np2: .data -@arr+2\\n@arr_np3: .data -@arr+3\\n@0: .data 0\\n@arr: .data 0 0 0\"}],\"currentSolutionName\":\"Untitled (1)\",\"solutionCycles\":200,\"solutionBytes\":143}","sic1_Puzzle_Reverse Sequence":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":335,\"solutionBytes\":97,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@read:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @print\\n@m1:\\nsubleq 128 128 ; SELF MODIFIED\\nsubleq 128 @a ; SELF MODIFIED\\nsubleq @a @a\\n\\nsubleq @m1 @n1\\nsubleq @m1+1 @n1\\nsubleq @m1+3 @n1\\nsubleq @m2+1 @n1\\nsubleq @a @a @read\\n\\n@print:\\nsubleq @m1 @1\\nsubleq @m1+1 @1\\nsubleq @m1+3 @1\\nsubleq @m2+1 @1\\n\\nsubleq @a @a\\n@m2:\\nsubleq @a 128 ; SELF MODIFIED\\nsubleq @OUT @a\\n\\nsubleq @a @a\\nsubleq @a @m1\\nsubleq @a @n128 @print\\n\\n; HACK\\nsubleq @m1 @n1\\nsubleq @m1+1 @n1\\nsubleq @m1+3 @n1\\nsubleq @m2+1 @n1\\n\\nsubleq @a @a @read\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@1: .data 1\\n@n1: .data -1\\n@0: .data 0\\n@n128: .data -128\",\"solutionCycles\":335,\"solutionBytes\":97}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Mode":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; TODO: improve by limiting scan to [input min, input max] instead of [0, 99]\\n@loop:\\n@reset:\\nsubleq @reset_c @reset_c\\nsubleq @reset_c @reset_s\\nsubleq @reset_i @reset_i\\nsubleq @reset_i @a_np\\nsubleq @reset_i+1 @reset_i+1\\nsubleq @reset_i+1 @a_np\\n\\n@reset_arr:\\nsubleq @reset_i:0 @reset_i\\nsubleq @reset_i @n_1\\nsubleq @reset_i+1 @n_1\\nsubleq @reset_c @n_1 @reset_arr\\n\\n@read:\\nsubleq @a @IN\\nsubleq @arr_i @arr_i\\nsubleq @arr_i @arr_np\\nsubleq @arr_i @a\\nsubleq @arr_i:0 @n_1\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @find\\nsubleq @a @a @read\\n\\n@find:\\nsubleq @arr_j @arr_j\\nsubleq @arr_j @arr_np\\nsubleq @maxc @maxc\\n\\n@find_l:\\nsubleq @a @a\\nsubleq @a @arr_j:0\\n\\nsubleq @b @b\\nsubleq @b @maxc\\nsubleq @c @c\\nsubleq @b @a @find_cont\\n\\n@update:\\nsubleq @maxc @maxc\\nsubleq @maxc @a\\nsubleq @b @b\\nsubleq @b @i\\nsubleq @max_i @max_i\\nsubleq @max_i @b\\n\\n@find_cont:\\nsubleq @b @b\\nsubleq @b @i\\nsubleq @b @n_99 @found\\nsubleq @i @n_1\\nsubleq @arr_j @n_1\\nsubleq @a @a @find_l\\n\\n@found:\\nsubleq @a @a\\nsubleq @a @max_i\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@arr_np: .data -@arr\\n@a_np: .data -@a\\n@0: .data 0\\n@n_1: .data -1\\n@n_99: .data -99\\n\\n@reset_c: .data 0\\n@reset_s: .data 106\\n\\n;resettable\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@i: .data 0\\n@max_i: .data 0\\n@maxc: .data 0\\n@arr: .data 0 ; actuall size is 100\"}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":5168,\"solutionBytes\":248}","sic1_Puzzle_Indicator Function":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"using ret, not enough memory\",\"code\":\"@start:\\n\\tsubleq @loop_b_i @loop_b_i\\n\\tsubleq @loop_b_i @arr_b_np\\n@read_a:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_a_np\\n\\tsubleq @0 @0 @read_arr @start_ret:\\n@read_b:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp2\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_b_np\\n\\tsubleq @0 @0 @read_arr @start_ret2:\\n@loop_b:\\n\\tsubleq @a @a\\n\\tsubleq @a @loop_b_i:255\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @xa @xa\\n\\tsubleq @xa @a\\n\\tsubleq @xa @0 @restart\\n\\t\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @start_nrp3\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @0 @0 @has @start_ret3:\\n\\n\\tsubleq @a @a\\n\\tsubleq @a @xr\\n\\tsubleq @OUT @a\\n@loop_b_cont:\\n\\tsubleq @loop_b_i @n_1\\n\\tsubleq @0 @0 @loop_b\\t\\n@restart:\\n\\tsubleq @a @a\\n\\tsubleq @a @arr_a_np\\n@reset_loop:\\n\\t.data -12 @n_1 @reset_loop+3\\n\\t;subleq @reset_c:12 @n1\\n\\t;subleq @a @a\\n\\t;subleq @reset_c @n1 @restart2\\n\\t;subleq @0 @0 @start\\n@restart2:\\n\\t!subleq @0 @0 @start\\n\\t\\n@start_nrp: .data -@start_ret\\n@start_nrp2: .data -@start_ret2\\n@start_nrp3: .data -@start_ret3\\n\\n\\n@arr_a: .data 0 0 0 0 0 0\\n@arr_b: .data 0 0 0 0 0 0\\n@arr_a_np: .data -@arr_a\\n@arr_b_np: .data -@arr_b\\n\\n; STD\\n\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\tsubleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @0 @0 @ret\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_ret\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_ret\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n@eq_ret:\\n\\tsubleq @0 @0 @ret\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n\\tsubleq @has_rpb @has_rpb\\n\\tsubleq @has_rpb @rp\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_nrp\\n\\tsubleq @0 @0 @eq @has_ret:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @rp @rp\\n\\tsubleq @rp @has_rpb\\n\\tsubleq @0 @0 @ret\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n@has_nrp: .data -@has_ret\\n@has_rpb: .data 0\\n\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n;@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n;@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n;@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n\"},{\"name\":\"Untitled (1)\",\"code\":\"@start:\\n\\tsubleq @loop_b_i @loop_b_i\\n\\tsubleq @loop_b_i @arr_b_np\\n@read_a:\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_a_np\\n\\tsubleq @0 @0 @read_arr\\n@read_b:\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_b_np\\n\\tsubleq @t @t\\n\\tsubleq @t @n_1\\n\\tsubleq @0 @0 @read_arr\\n@loop_b:\\n\\tsubleq @a @a\\n\\tsubleq @a @loop_b_i:255\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @xa @xa\\n\\tsubleq @xa @a\\n\\tsubleq @xa @0 @restart\\n\\t\\n\\tsubleq @has_i @has_i\\n\\tsubleq @has_i @arr_a_np\\n\\tsubleq @0 @0 @has @has_back:\\n\\n\\tsubleq @a @a\\n\\tsubleq @a @xr\\n\\tsubleq @OUT @a\\n@loop_b_cont:\\n\\tsubleq @loop_b_i @n_1\\n\\tsubleq @0 @0 @loop_b\\t\\n@restart:\\n\\tsubleq @reset_c @reset_c\\n\\tsubleq @reset_c @12\\n\\tsubleq @clear_i @clear_i\\n\\tsubleq @clear_i @arr_a_np\\n\\tsubleq @clear_i+1 @clear_i+1\\n\\tsubleq @clear_i+1 @arr_a_np\\n@reset_loop:\\n\\tsubleq @clear_i:0 @clear_i\\n\\tsubleq @clear_i @n_1\\n\\tsubleq @clear_i+1 @n_1\\n\\tsubleq @reset_c @n_1 @reset_loop\\n\\n\\tsubleq @0 @0 @start\\n\\n\\n@arr_a: .data 0 0 0 0 0 0\\n@arr_b: .data 0 0 0 0 0 0\\n@t: .data 0\\n@reset_c: .data 0\\n@arr_a_np: .data -@arr_a\\n@arr_b_np: .data -@arr_b\\n\\n; STD\\n\\n\\n; jump to rp\\n@ret:\\n\\tsubleq @0 @0 @rp:255 ; PATCH\\n\\n; read values from @IN until read 0\\n; write every value (except 0) consecutively to @read_arr_i\\n; @read_arr_i: array (must patch)\\n@read_arr:\\n\\tsubleq @a @a\\n\\tsubleq @a @IN\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @read_arr_done\\n@read_arr_write:\\n\\tsubleq @read_arr_i:255 @a\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @0 @0 @read_arr\\n@read_arr_done:\\n\\tsubleq @t @0 @read_b\\n\\tsubleq @0 @0 @loop_b\\n\\n; xr: 1 if xa == xb, 0 otherwise\\n@eq:\\n\\tsubleq @a @a\\n\\tsubleq @a @xa\\n\\tsubleq @b @b\\n\\tsubleq @b @xb\\n\\tsubleq @a @b @eq_le\\n\\tsubleq @xr @xr @eq_back\\n@eq_le:\\n\\tsubleq @b @b\\n\\tsubleq @b @a\\n\\tsubleq @b @0 @eq_0\\n\\tsubleq @xr @xr @eq_back\\n@eq_0:\\n\\tsubleq @xr @xr\\n\\tsubleq @xr @n_1\\n\\tsubleq @0 @0 @eq_back\\n\\n; xa: value\\n; @has_i: array (must patch)\\n; xr: 1 if array has xa, 0 otherwise\\n@has:\\n\\tsubleq @xr @xr\\n@has_loop:\\n\\tsubleq @a @a\\n\\tsubleq @a @has_i:255\\n\\tsubleq @xb @xb\\n\\tsubleq @xb @a\\n\\tsubleq @xb @0 @has_done\\n\\tsubleq @0 @0 @eq @eq_back:\\n\\tsubleq @xr @0 @has_cont\\n@has_done:\\n\\tsubleq @0 @0 @has_back\\n@has_cont:\\n\\tsubleq @has_i @n_1\\n\\tsubleq @0 @0 @has_loop\\n\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n;@c: .data 0\\n\\n; call regs\\n@xa: .data 0 ; arg 1 reg\\n@xb: .data 0 ; arg 2 reg\\n;@xc: .data 0 ; arg 3 reg\\n@xr: .data 0 ; proc return reg\\n\\n; consts\\n;@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n@12: .data 12\"}],\"currentSolutionName\":\"Untitled (1)\",\"solutionCycles\":562,\"solutionBytes\":236}","sic1_Puzzle_Self-Hosting":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @4\\n@pfx_loop:\\nsubleq @a @IN\\nsubleq @f @n_1 @pfx_loop\\n\\n!subleq @a @n_10 @subleq_stmt\\nsubleq @a @a @data_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@subleq_stmt:\\nsubleq @a @IN\\nsubleq @a @IN\\n\\nsubleq @f @f\\nsubleq @f @n_3\\nsubleq @0 @0 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @f @f\\nsubleq @f @n_2 @ns_loop\\n\\n@ns_loop:\\n!subleq @f @1 @next_stmt\\n\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @OUT @c\\nsubleq @0 @0 @ns_loop\\n\\n@write_byte:\\nsubleq @w_i:0 @b\\nsubleq @w_i @n_1\\nsubleq @0 @0 @HALT\\n\\n; read chars from @IN until invalid digit, write negated parsed int to @c\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @10 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\n\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @0 @0 @nmul @nmul_ret:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret\\n\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@n_3: .data -3\\n@3: .data 3\\n@4: .data 4\\n@10: .data -10\\n@n_10: .data 10\\n\"},{\"name\":\"stupid empty line\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @4\\n@pfx_loop:\\nsubleq @a @IN\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @10 @subleq_stmt\\nsubleq @a @a @data_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@subleq_stmt:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @0 @comp_done\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @a @IN\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @0 @0 @nmul @nmul_ret:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret\\n\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@4: .data 4\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@n_47: .data -47\\n\"},{\"name\":\"255 should jump to reset not halt\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @empty_line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\nsubleq @a @a @subleq_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@empty_line:\\nsubleq @a @a @next_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @0 @0 @nmul @nmul_ret:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\nsubleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret\\n\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"Untitled (1)\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @empty_line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\nsubleq @a @a @subleq_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@empty_line:\\nsubleq @a @a @next_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @f @0 @skip_negt\\n!subleq @a @a\\nsubleq @a @c\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @c @c\\nsubleq @c @b\\n@skip_negt:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"refactoring\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @empty_line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\nsubleq @a @a @subleq_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@empty_line:\\nsubleq @a @a @next_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"last bug with .data -1\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @empty_line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@empty_line:\\nsubleq @a @a @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@write_halt:\\n;subleq @c @c ; c is known to be 0 already\\nsubleq @c @1 @write_cont\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"correct but does not fit 6 bytes\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0; 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @is_data_stmt @is_data_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @empty_line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\n\\n@subleq_done:\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@empty_line:\\nsubleq @a @a @next_stmt\\n\\n@data_stmt:\\nsubleq @is_data_stmt @n_1\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@write_halt:\\nsubleq @is_data_stmt @0 @write_cont\\nsubleq @c @1 @write_cont ; write non-halt whatever\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_data_stmt: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@n_10: .data -10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"still -1 bug\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\nsubleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @is_data_stmt @is_data_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@data_stmt:\\nsubleq @is_data_stmt @n_1\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@write_halt:\\nsubleq @is_data_stmt @0 @write_cont\\nsubleq @c @1 @write_cont ; write non-halt whatever\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_data_stmt: .data 0\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"reset is needed...\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\n!subleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\nsubleq @0 @0 @ns_loop\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\nsubleq @c @1 @write_cont ; write non-halt whatever\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"trying to fit reset\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\n!subleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@ns_cont:\\nsubleq @0 @0 @pint @pint_ret:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\n\\n@ns_loop:\\nsubleq @g @n_1 @ns_cont\\nsubleq @0 @0 @next_stmt\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\nsubleq @c @reset_np\\nsubleq @0 @0 @write_cont ; write non-halt whatever\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\n\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n@pint_done2:\\nsubleq @0 @0 @pint_ret\\n\\n@reset:\\n;subleq @0 @0 @comp_start\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n@reset_np: .data -@reset\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"trying to fit mem clear\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\n!subleq @2:@init_j @init_j\\n\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n\\n@nmul_done:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n\\n@pint_done2:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @w_i:0 @c\\nsubleq @w_i @n_1\\n\\n@ns_loop:\\nsubleq @g @n_1 @pint\\nsubleq @0 @0 @next_stmt\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\nsubleq @c @reset_p\\nsubleq @0 @0 @write_cont ; update with reset addr\\n\\n@reset:\\nsubleq @0 @0 @comp_start\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n@reset_p: .data @reset\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"trying to fit mem clear (1)\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\\n@comp_start:\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@comp_done:\\nsubleq @0 @0 @prog\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n\\n@nmul_done:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n\\n@pint_done2:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @r_i:0 @r_j:0\\nsubleq @w_i:0 @c\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\n\\n@ns_loop:\\nsubleq @g @n_1 @pint\\nsubleq @0 @0 @next_stmt\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\nsubleq @c @reset_p\\nsubleq @0 @0 @write_cont ; update with reset addr\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n@reset_p: .data @comp_start\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"},{\"name\":\"latest\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 ; TODO: support full 21 bytes\\n\\n@comp_start:\\nsubleq @w_i @w_i\\nsubleq @r_i @r_i\\nsubleq @r_j @r_j\\n\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n\\n@nmul_done:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n\\n@pint_done2:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @r_i:0 @r_j:0\\nsubleq @w_i:0 @c\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\n\\n@ns_loop:\\nsubleq @g @n_1 @pint\\nsubleq @0 @0 @next_stmt\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\n; @c is always 0 here\\nsubleq @c @reset_p @write_cont\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n@reset_p: .data @comp_start\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"}],\"currentSolutionName\":\"latest\",\"solutionCycles\":1157,\"solutionBytes\":245}","sic1_steamApi":"{\"leaderboardQueue\":{\"limiter\":{\"rate\":{\"count\":10,\"periodMS\":600000},\"history\":[\"2024-09-15T23:20:39.750Z\",\"2024-09-15T23:20:39.750Z\",\"2024-09-15T23:20:40.750Z\"]},\"queue\":[]}}","sic1_Puzzle_Multi-Line Strings":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":122,\"solutionBytes\":24,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @10 @nl\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n@nl:\\nsubleq @OUT @0\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@10: .data 10\\n@0: .data 0\",\"solutionCycles\":143,\"solutionBytes\":30},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @n_11 @cont\\nsubleq @a @n_10\\n@cont:\\nsubleq @a @11\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@11: .data 11\\n@n_11: .data -11\\n@n_10: .data -10\",\"solutionCycles\":122,\"solutionBytes\":24}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Strings":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":40,\"solutionBytes\":26,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @OUT, @c:@msg\\nsubleq @c, @n_1\\nsubleq @tmp, @tmp, @loop\\n\\n@n_1: .data -1\\n@msg: .data -\\\"Hello, world!\\\"\\n@tmp: .data 0\\n\",\"solutionCycles\":40,\"solutionBytes\":26}],\"currentSolutionName\":\"Untitled\"}","sic1_":"{\"userId\":\"exwrbenroyunzgo\",\"name\":\"COOKIEEEEEEEEEEEEEEEE\",\"introCompleted\":true,\"solvedCount\":30,\"currentPuzzle\":\"Self-Hosting Part 2\",\"generation\":3,\"inbox\":[{\"id\":\"s0_0\",\"read\":true},{\"id\":\"s0_1\",\"read\":true},{\"id\":\"s0_2\",\"read\":true},{\"id\":\"Subleq Instruction and Output\",\"read\":true},{\"id\":\"s1_0\",\"read\":true},{\"id\":\"Data Directive and Looping\",\"read\":true},{\"id\":\"s2_0\",\"read\":true},{\"id\":\"s2_1\",\"read\":true},{\"id\":\"First Assessment\",\"read\":true},{\"id\":\"s3_0\",\"read\":true},{\"id\":\"s3_1\",\"read\":true},{\"id\":\"Addition\",\"read\":true},{\"id\":\"s4_0\",\"read\":true},{\"id\":\"s4_1\",\"read\":true},{\"id\":\"Subtraction\",\"read\":true},{\"id\":\"s5_0\",\"read\":true},{\"id\":\"Sign Function\",\"read\":true},{\"id\":\"s6_0\",\"read\":true},{\"id\":\"Multiplication\",\"read\":true},{\"id\":\"s7_0\",\"read\":true},{\"id\":\"s7_1\",\"read\":true},{\"id\":\"Division\",\"read\":true},{\"id\":\"s8_0\",\"read\":true},{\"id\":\"Sequence Sum\",\"read\":true},{\"id\":\"s9_0\",\"read\":true},{\"id\":\"Sequence Cardinality\",\"read\":true},{\"id\":\"s10_0\",\"read\":true},{\"id\":\"Number to Sequence\",\"read\":true},{\"id\":\"s11_0\",\"read\":true},{\"id\":\"Self-Modifying Code\",\"read\":true},{\"id\":\"s12_0\",\"read\":true},{\"id\":\"Stack Memory\",\"read\":true},{\"id\":\"s13_0\",\"read\":true},{\"id\":\"Reverse Sequence\",\"read\":true},{\"id\":\"s14_0\",\"read\":true},{\"id\":\"Interleave\",\"read\":true},{\"id\":\"s15_0\",\"read\":true},{\"id\":\"Indicator Function\",\"read\":true},{\"id\":\"s16_0\",\"read\":true},{\"id\":\"Sort\",\"read\":true},{\"id\":\"s17_0\",\"read\":true},{\"id\":\"Mode\",\"read\":true},{\"id\":\"s18_0\",\"read\":true},{\"id\":\"Characters\",\"read\":true},{\"id\":\"s19_0\",\"read\":true},{\"id\":\"Decimal Digits\",\"read\":true},{\"id\":\"s20_0\",\"read\":true},{\"id\":\"Uppercase\",\"read\":true},{\"id\":\"s21_0\",\"read\":true},{\"id\":\"Strings\",\"read\":true},{\"id\":\"s22_0\",\"read\":true},{\"id\":\"s22_1\",\"read\":true},{\"id\":\"Tokenizer\",\"read\":true},{\"id\":\"s23_0\",\"read\":true},{\"id\":\"Parse Decimal\",\"read\":true},{\"id\":\"s24_0\",\"read\":true},{\"id\":\"s24_1\",\"read\":true},{\"id\":\"Print Decimal\",\"read\":true},{\"id\":\"s25_0\",\"read\":true},{\"id\":\"Calculator\",\"read\":true},{\"id\":\"s26_0\",\"read\":true},{\"id\":\"s26_1\",\"read\":true},{\"id\":\"Multi-Line Strings\",\"read\":true},{\"id\":\"s27_0\",\"read\":true},{\"id\":\"s27_1\",\"read\":true},{\"id\":\"Parse Data Directives\",\"read\":true},{\"id\":\"s28_0\",\"read\":true},{\"id\":\"Parse Subleq Instructions\",\"read\":true},{\"id\":\"s29_0\",\"read\":true},{\"id\":\"Self-Hosting\",\"read\":true},{\"id\":\"s30_0\",\"read\":true}],\"colorScheme\":\"White on Black\",\"tabInsertMode\":true}","sic1__avoision":"{\"score\":251}","sic1_Puzzle_Addition":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":19,\"solutionBytes\":15,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @b @b\\nsubleq @a @IN\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @b\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":49,\"solutionBytes\":34},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":19,\"solutionBytes\":15},{\"name\":\"Untitled (2)\",\"code\":\"; Read two numbers and output their sum. Repeat.\\n;\\n; Below is the solution to the previous task. You will need to add\\n; additional code to perform addition of two inputs (instead of\\n; passing through a single input):\\n\\n.data 12, -3, 3, 12, -3, 6, -2, 12, 9, 12, 12\",\"solutionCycles\":19,\"solutionBytes\":15}],\"currentSolutionName\":\"Untitled (2)\"}","sic1_Puzzle_Decimal Digits":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":11,\"solutionBytes\":16,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @off\\nsubleq @OUT @a @loop\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@off: .data -48\\n\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Tokenizer":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @space @end\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n@end:\\nsubleq @OUT @0 @loop\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@0: .data 0\\n@space: .data ' '\",\"solutionCycles\":259,\"solutionBytes\":30}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":259,\"solutionBytes\":30}","sic1_Puzzle_Uppercase":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":61,\"solutionBytes\":43,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @lo_lim @skip\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @hi_lim @cont\\nsubleq @b @b @skip\\n@cont:\\nsubleq @a @off\\nsubleq @OUT @a @loop\\nsubleq @a @a @loop\\n@skip:\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@off: .data -32\\n@lo_lim: .data 96\\n@hi_lim: .data 122\",\"solutionCycles\":61,\"solutionBytes\":43}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Subleq Instruction and Output":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":1,\"solutionBytes\":5,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; The Single Instruction Computer Mark 1 (SIC-1) is an 8-bit computer\\n; with 256 bytes of memory. Programs for the SIC-1 are written in\\n; SIC-1 Assembly Language.\\n;\\n; Each instruction is 3 bytes, specified as follows:\\n;\\n;   subleq <A> <B> [<C>]\\n;\\n; A, B, and C are memory addresses (0 - 255) or labels.\\n;\\n; \\\"subleq\\\" subtracts the value at address B from the value at address\\n; A and stores the result at address A (i.e. mem[A] ← mem[A] -\\n; mem[B]).\\n;\\n; If the result is <= 0, execution branches to address C.\\n;\\n; Note that if C is not specified, the address of the next\\n; instruction is automatically added by the assembler (in effect,\\n; this means that taking the branch is no different from advancing to\\n; the next instruction).\\n;\\n; For convenience, addresses can be specified using labels. The\\n; following predefined labels are always available:\\n;\\n;   @MAX (252): Maximum user-modifiable address\\n;   @IN (253): Reads a value from input (writes are ignored)\\n;   @OUT (254): Writes a result to output (reads as zero)\\n;   @HALT (255): Terminates the program when accessed\\n;\\n; Note: any text following a semicolon is considered a comment.\\n; Comments are ignored by the assembler.\\n; \\n; Below is a very simple SIC-1 program that negates one input value\\n; and writes it out.\\n;\\n; E.g. if the input value from @IN is 3, it subtracts 3 from @OUT\\n; (which reads as zero), and the result of 0 - 3 = -3 is written out.\\n\\nsubleq @OUT @IN\\n\\n; Use the \\\"Compile/Step\\\" (Ctrl+.) and \\\"Run\\\" (Ctrl+Enter) buttons to\\n; execute the program until all expected outputs have been\\n; successfully written out (see the \\\"In\\\"/\\\"Expected\\\"/\\\"Out\\\" table to\\n; the left).\\n\",\"solutionCycles\":1,\"solutionBytes\":5},{\"name\":\"Untitled (1)\",\"code\":\"; The Single Instruction Computer Mark 1 (SIC-1) is an 8-bit computer\\n; with 256 bytes of memory. Programs for the SIC-1 are written in\\n; SIC-1 Assembly Language.\\n;\\n; Each instruction is 3 bytes, specified as follows:\\n;\\n;   subleq <A> <B> [<C>]\\n;\\n; A, B, and C are memory addresses (0 - 255) or labels.\\n;\\n; \\\"subleq\\\" subtracts the value at address B from the value at address\\n; A and stores the result at address A (i.e. mem[A] ← mem[A] -\\n; mem[B]).\\n;\\n; If the result is <= 0, execution branches to address C.\\n;\\n; Note that if C is not specified, the address of the next\\n; instruction is automatically added by the assembler (in effect,\\n; this means that taking the branch is no different from advancing to\\n; the next instruction).\\n;\\n; For convenience, addresses can be specified using labels. The\\n; following predefined labels are always available:\\n;\\n;   @MAX (252): Maximum user-modifiable address\\n;   @IN (253): Reads a value from input (writes are ignored)\\n;   @OUT (254): Writes a result to output (reads as zero)\\n;   @HALT (255): Terminates the program when accessed\\n;\\n; Note: any text following a semicolon is considered a comment.\\n; Comments are ignored by the assembler.\\n; \\n; Below is a very simple SIC-1 program that negates one input value\\n; and writes it out.\\n;\\n; E.g. if the input value from @IN is 3, it subtracts 3 from @OUT\\n; (which reads as zero), and the result of 0 - 3 = -3 is written out.\\n\\n;subleq @OUT, @IN\\n.data -2 -3 3\\n\\n; Use the \\\"Compile/Step\\\" (Ctrl+.) and \\\"Run\\\" (Ctrl+Enter) buttons to\\n; execute the program until all expected outputs have been\\n; successfully written out (see the \\\"In\\\"/\\\"Expected\\\"/\\\"Out\\\" table to\\n; the left).\\n\",\"solutionCycles\":1,\"solutionBytes\":5}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Multiplication":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":96,\"solutionBytes\":46,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"; Read two nonnegative numbers and output the resulting (nonnegative)\\n; product. Repeat.\\n\\n@loop:\\nsubleq @a @IN\\nsubleq @c @IN\\nsubleq @b @c @res\\nsubleq @c @c\\n\\n@acc:\\nsubleq @n @a\\nsubleq @b @1 @res\\nsubleq @c @c @acc\\n\\n@res:\\nsubleq @c @c\\nsubleq @c @n\\nsubleq @OUT @c\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @n @n @loop \\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@n: .data 0\\n@0: .data 0\\n@1: .data 1\",\"solutionCycles\":96,\"solutionBytes\":46}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Self-Hosting Part 2":"{\"unlocked\":true,\"viewed\":true,\"solved\":false,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@prog: .data 0 0 @init_j:@comp_start 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0; 0 0 0 ; TODO: support full 21 bytes\\n\\n@comp_start:\\nsubleq @w_i @w_i\\nsubleq @r_i @r_i\\nsubleq @r_j @r_j\\n\\n@next_stmt:\\nsubleq @is_sub_stmt @is_sub_stmt\\nsubleq @f @f\\nsubleq @f @5\\n@pfx_loop:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @comp_done\\nsubleq @b @10 @next_stmt ; empty line\\n@empty_line_cont:\\nsubleq @f @n_1 @pfx_loop\\n\\nsubleq @a @33 @data_stmt\\n\\n@subleq_stmt:\\nsubleq @is_sub_stmt @n_1\\nsubleq @a @IN\\n\\nsubleq @g @g\\nsubleq @g @3 @ns_loop\\nsubleq @0 @0 @next_stmt\\n\\n@data_stmt:\\nsubleq @g @g\\nsubleq @g @1 @ns_loop\\n\\n@pint:\\nsubleq @d @d\\nsubleq @f @f\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @0 @pint_done\\nsubleq @b @n_1\\n\\nsubleq @c @c\\nsubleq @c @e\\nsubleq @c @32 @pint_done\\nsubleq @c @c\\nsubleq @c @b\\nsubleq @e @n_atoi_off\\nsubleq @c @n_47 @skip_neg\\n@do_neg:\\nsubleq @f @n_1\\nsubleq @0 @0 @pint_loop\\n@skip_neg:\\nsubleq @b @1\\n\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\n\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @10\\nsubleq @0 @0 @nmul_loop\\n\\n@nmul_done:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @f @0 @pint_pos\\nsubleq @c @a\\nsubleq @0 @0 @pint_done2\\n@pint_pos:\\nsubleq @c @d\\n\\n@pint_done2:\\nsubleq @0 @0 @write_byte\\n\\n@write_byte:\\nsubleq @c @0 @write_cont\\nsubleq @c @1 @write_halt\\n\\n@write_and_inc:\\nsubleq @c @n_1\\n\\n@write_cont:\\nsubleq @r_i:0 @r_j:0\\nsubleq @w_i:0 @c\\n\\nsubleq @w_i @n_1\\nsubleq @r_i @n_1\\nsubleq @r_j @n_1\\n\\n@ns_loop:\\nsubleq @g @n_1 @pint\\nsubleq @0 @0 @next_stmt\\n\\n@write_halt:\\nsubleq @is_sub_stmt @0 @write_and_inc\\n; @c is always 0 here\\nsubleq @c @reset_p @write_cont\\n\\n@comp_done:\\n!subleq @0 @0 @prog\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n\\n@is_sub_stmt: .data 0\\n@reset_p: .data @comp_start\\n\\n@n_atoi_off: .data -48\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@3: .data 3\\n@5: .data 5\\n@10: .data 10\\n@32: .data 32\\n@33: .data 33\\n@n_47: .data -47\\n\"}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Parse Subleq Instructions":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":546,\"solutionBytes\":161,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\nsubleq @a @IN\\n\\nsubleq @f @f\\nsubleq @f @n_3\\n\\n@ns_loop:\\nsubleq @f @0 @loop\\nsubleq @f @1\\n\\nsubleq @pint_ret @pint_ret\\nsubleq @pint_ret @b1_np\\nsubleq @0 @0 @pint @b1:\\nsubleq @OUT @c\\nsubleq @0 @0 @ns_loop\\n\\n; read chars from @IN until invalid digit, write negated parsed int to @c\\n@pint:\\nsubleq @d @d\\n@pint_loop:\\nsubleq @e @e\\nsubleq @e @IN\\nsubleq @b @b\\nsubleq @b @e\\nsubleq @b @n_1\\nsubleq @b @atoi_off @pint_done\\nsubleq @b @1\\nsubleq @e @n_atoi_off\\n\\nsubleq @d @0 @pint_cont ; don't *=10 on first iteration\\nsubleq @a @a\\nsubleq @a @d\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @a @a\\nsubleq @a @n_10\\n\\nsubleq @nmul_ret @nmul_ret\\nsubleq @nmul_ret @b2_np\\nsubleq @0 @0 @nmul @b2:\\nsubleq @d @d\\nsubleq @d @c\\n\\n@pint_cont:\\nsubleq @d @e\\nsubleq @0 @0 @pint_loop\\n\\n@pint_done:\\nsubleq @c @c\\nsubleq @c @d\\nsubleq @0 @0 @pint_ret:0\\n\\n; negative multiplication, for all @a>0, @b>0 set @c=-(@a*@b), @a=@a, @b=0\\n@nmul:\\nsubleq @c @c\\nsubleq @b @n_1\\n@nmul_loop:\\nsubleq @b @1 @nmul_done\\nsubleq @c @a\\nsubleq @0 @0 @nmul_loop\\n@nmul_done:\\nsubleq @0 @0 @nmul_ret:0\\n\\n\\n@b1_np: .data -@b1\\n@b2_np: .data -@b2\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n@f: .data 0\\n@g: .data 0\\n@h: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@c_star: .data '*'\\n@0: .data 0\\n@1: .data 1\\n@n_1: .data -1\\n@n_2: .data -2\\n@n_3: .data -3\\n@n_10: .data -10\",\"solutionCycles\":546,\"solutionBytes\":161}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Subtraction":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":29,\"solutionBytes\":22,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @IN\\nsubleq @a @b\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\",\"solutionCycles\":29,\"solutionBytes\":22}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Characters":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":2,\"solutionBytes\":9,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"subleq @OUT, @s\\nsubleq @OUT, @s+1\\n\\n@s: .data -'H' -'i'\\n\\n\",\"solutionCycles\":2,\"solutionBytes\":9}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Sequence Sum":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":87,\"solutionBytes\":32,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @endseq\\n\\nsubleq @acc @b @inner\\n\\n@endseq:\\nsubleq @OUT @acc\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\",\"solutionCycles\":115,\"solutionBytes\":33},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @acc @a\\nsubleq @a @n1 @cont\\nsubleq @a @a @endseq\\n\\n@cont:\\nsubleq @a @a @inner\\n\\n@endseq:\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":87,\"solutionBytes\":32},{\"name\":\"Untitled (2)\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @acc @a\\nsubleq @a @n1 @cont\\n\\n@endseq:\\nsubleq @a @a\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@cont:\\nsubleq @a @a @inner\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\"}],\"currentSolutionName\":\"Untitled (2)\"}","sic1_Puzzle_Sign Function":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":30,\"solutionBytes\":33,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a @lez\\nsubleq @OUT @n1\\nsubleq @a @a @loop\\n\\n@lez:\\nsubleq @a @a\\nsubleq @a @b @ez\\nsubleq @a @a\\nsubleq @OUT @1 @loop\\n\\n@ez:\\nsubleq @OUT @a @loop\\n\\n@gz:\\nsubleq @OUT @n1\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":42,\"solutionBytes\":36},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @a @IN @gez\\nsubleq @a @a\\nsubleq @OUT @1 @loop\\n\\n@gez:\\nsubleq @b @a @ez\\nsubleq @a @a\\nsubleq @b @b\\nsubleq @OUT @n1 @loop\\nsubleq @a @a @loop\\n\\n@ez:\\nsubleq @OUT @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":30,\"solutionBytes\":33}],\"currentSolutionName\":\"Untitled\"}","sic1_Puzzle_Sequence Cardinality":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutionCycles\":27,\"solutionBytes\":17,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @acc @acc\\n\\n@inner:\\nsubleq @a @IN\\nsubleq @a @n1 @cont\\n\\n@endseq:\\nsubleq @a @a\\nsubleq @a @acc\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@cont:\\nsubleq @acc @n1\\nsubleq @a @a @inner\\n\\n@a: .data 0\\n@b: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":59,\"solutionBytes\":32},{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\n\\n@inner:\\nsubleq @IN @0 @endseq\\n\\n@cont:\\nsubleq @acc @1 @inner\\n\\n@endseq:\\nsubleq @OUT @acc\\nsubleq @acc @acc @loop\\n\\n@a: .data 0\\n@acc: .data 0\\n\\n@0: .data 0\\n@1: .data 1\",\"solutionCycles\":27,\"solutionBytes\":17}],\"currentSolutionName\":\"Untitled (1)\"}","sic1_Puzzle_Interleave":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@read1:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @read2\\nsubleq 128 @b ; PATCH\\n\\nsubleq @read1+15 @n1\\nsubleq @a @a @read1\\n\\n@read2:\\nsubleq @a @a\\nsubleq @a @IN\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @0 @interl\\nsubleq 144 @b ; PATCH\\n\\nsubleq @read2+15 @n1\\nsubleq @a @a @read2\\n\\n@interl:\\nsubleq @a @a\\nsubleq @a 128 @done ; PATCH\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @OUT @b\\n\\nsubleq @a @a\\nsubleq @a 144 @done ; PATCH\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @OUT @b\\n\\nsubleq @interl+4 @n1\\nsubleq @interl+19 @n1\\nsubleq @b @b @interl\\n\\n@done:\\nsubleq @OUT @0 @read1\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":329,\"solutionBytes\":117}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":329,\"solutionBytes\":117}","sic1_Puzzle_Sort":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\n\\tsubleq @reset_c @reset_c\\n\\tsubleq @reset_c @12\\n\\tsubleq @reset_i @reset_i\\n\\tsubleq @reset_i @arr_np\\n\\tsubleq @reset_i+1 @reset_i+1\\n\\tsubleq @reset_i+1 @arr_np\\n@reset_arr:\\n\\tsubleq @reset_i:0 @reset_i\\n\\tsubleq @reset_i @n_1\\n\\tsubleq @reset_i+1 @n_1\\n\\tsubleq @reset_c @n_1 @reset_arr\\n\\tsubleq @read_arr_i @read_arr_i\\n\\tsubleq @read_arr_i @arr_np\\n\\tsubleq @a @a @read @read_arr_back:\\n@sort:\\n\\tsubleq @i @i\\n\\tsubleq @i @arr_np\\n\\tsubleq @swap_i @swap_i\\n\\tsubleq @swap_i @arr_np\\n\\tsubleq @clear_i @clear_i\\n\\tsubleq @clear_i @arr_np\\n\\tsubleq @clear_i+1 @clear_i+1\\n\\tsubleq @clear_i+1 @arr_np\\n\\tsubleq @j @j\\n\\tsubleq @j @arr_np\\n\\tsubleq @j @n_1\\n\\tsubleq @swap_j @swap_j\\n\\tsubleq @swap_j @arr_np\\n\\tsubleq @swap_j @n_1\\n\\tsubleq @clear_j @clear_j\\n\\tsubleq @clear_j @arr_np\\n\\tsubleq @clear_j @n_1\\n\\tsubleq @clear_j+1 @clear_j+1\\n\\tsubleq @clear_j+1 @arr_np\\n\\tsubleq @clear_j+1 @n_1\\n@sort_inner:\\n\\tsubleq @a @a\\n\\tsubleq @a @i:0\\n\\tsubleq @d @d\\n\\tsubleq @d @a\\n\\tsubleq @c @c\\n\\tsubleq @c @d\\n\\n\\tsubleq @b @b\\n\\tsubleq @b @j:0\\n\\tsubleq @d @d\\n\\tsubleq @d @b\\n\\tsubleq @d @0 @pass_complete\\n\\n\\tsubleq @c @n_1\\n\\tsubleq @c @b @swap\\n\\tsubleq @print @0 @sort_cont\\n\\tsubleq @OUT @a\\n@sort_cont:\\n\\tsubleq @i @n_1\\n\\tsubleq @j @n_1\\n\\tsubleq @swap_i @n_1\\n\\tsubleq @swap_j @n_1\\n\\tsubleq @clear_i @n_1\\n\\tsubleq @clear_i+1 @n_1\\n\\tsubleq @clear_j @n_1\\n\\tsubleq @clear_j+1 @n_1\\n\\tsubleq @0 @0 @sort_inner\\n@swap:\\n\\tsubleq @dirty @n_1\\n\\tsubleq @clear_i:0 @clear_i\\n\\tsubleq @clear_j:0 @clear_j\\n\\tsubleq @swap_i:0 @b\\n\\tsubleq @swap_j:0 @a @sort_cont\\n@pass_complete:\\n\\tsubleq @print @0 @no_print\\n\\tsubleq @OUT @a\\n\\tsubleq @OUT @0\\n@no_print:\\n\\tsubleq @dirty @0 @sorted\\n\\tsubleq @dirty @dirty @sort\\n@sorted:\\n\\tsubleq @print @0 @start_print\\n\\tsubleq @print @1\\n\\tsubleq @0 @0 @loop\\n@start_print:\\n\\tsubleq @print @n_1\\n\\tsubleq @0 @0 @sort\\n@read:\\n\\tsubleq @a @IN\\n@write:\\n\\tsubleq @read_arr_i:255 @a @write_done\\n\\tsubleq @read_arr_i @n_1\\n\\tsubleq @a @a @read\\n@write_done:\\n\\tsubleq @0 @0 @read_arr_back\\n\\n@arr_np: .data -@arr\\n@current: .data 0\\n@dirty: .data 0\\n@print: .data 0\\n@reset_c: .data 0\\n\\n; tmp regs\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n; consts\\n@1: .data 1\\n@n_1: .data -1\\n@0: .data 0\\n@12: .data 8\\n\\n@arr: .data 0 0 0 0 0 0 0 0 1\",\"solutionCycles\":1670,\"solutionBytes\":254}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":1670,\"solutionBytes\":254}","sic1_Puzzle_Print Decimal":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @n @n\\nsubleq @n @IN\\nsubleq @a @a\\nsubleq @a @n\\nsubleq @b @b\\nsubleq @b @n\\nsubleq @b @n_1\\nsubleq @b @10 @l10\\nsubleq @n @n_100 @ge100\\nsubleq @n @100\\n@c10:\\nsubleq @b @b\\n@c10_loop:\\nsubleq @n @n_10 @c10_cont\\nsubleq @n @10\\nsubleq @0 @0 @p10\\n@c10_cont:\\nsubleq @b @1\\nsubleq @0 @0 @c10_loop\\n@p10:\\nsubleq @a @a\\nsubleq @a @b\\nsubleq @b @atoi_off\\nsubleq @OUT @b\\nsubleq @a @a\\nsubleq @a @n\\n@p1:\\nsubleq @b @b\\nsubleq @b @a\\nsubleq @b @atoi_off\\nsubleq @OUT @b\\nsubleq @OUT @0\\nsubleq @0 @0 @loop\\n\\n@ge100:\\nsubleq @a @100\\nsubleq @OUT @n_s1\\nsubleq @0 @0 @c10\\n\\n@l10:\\nsubleq @n @atoi_off\\nsubleq @OUT @n\\nsubleq @OUT @0\\nsubleq @0 @0 @loop\\n\\n@n: .data 0\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n\\n@atoi_off: .data 48\\n@n_atoi_off: .data -48\\n@1: .data 1\\n@n_1: .data -1\\n@10: .data 10\\n@n_10: .data -10\\n@n_100: .data -100\\n@100: .data 100\\n@n_s1: .data -'1'\\n@0: .data 0\",\"solutionCycles\":90,\"solutionBytes\":109}],\"currentSolutionName\":\"Untitled\",\"solutionCycles\":90,\"solutionBytes\":109}","sic1_Puzzle_Division":"{\"unlocked\":true,\"viewed\":true,\"solved\":true,\"solutions\":[{\"name\":\"Untitled (1)\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @a @a\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @a @IN\\nsubleq @dv @a\\nsubleq @dr @IN\\n\\n@l2:\\nsubleq @dv @0 @res\\nsubleq @dv @1\\nsubleq @r @n1\\n\\nsubleq @a @a\\nsubleq @a @dr\\nsubleq @a @r @nextq\\nsubleq @a @a @l2\\n\\n@nextq:\\nsubleq @r @r\\nsubleq @q @n1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @e @e\\nsubleq @e @q\\nsubleq @OUT @e\\nsubleq @e @e\\nsubleq @e @r\\nsubleq @OUT @e\\nsubleq @r @r @loop\\n\\n@a: .data 0\\n@b: .data 0\\n@c: .data 0\\n@d: .data 0\\n@e: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n@r: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":755,\"solutionBytes\":83},{\"name\":\"Untitled\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @a @a\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @a @IN\\nsubleq @dv @a\\nsubleq @b @b\\nsubleq @b @IN\\nsubleq @dr @b\\n\\n@l2:\\nsubleq @a @a\\nsubleq @a @dr\\nsubleq @b @b\\nsubleq @b @dv\\nsubleq @b @a @nextq\\nsubleq @a @a @res\\n\\n@nextq:\\nsubleq @dv @dr\\nsubleq @q @n1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @a @a\\nsubleq @a @dv\\nsubleq @a @a\\nsubleq @a @q\\nsubleq @OUT @a\\n\\nsubleq @a @a\\nsubleq @a @dv\\nsubleq @OUT @a\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n@r: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":247,\"solutionBytes\":89},{\"name\":\"Untitled (2)\",\"code\":\"@loop:\\nsubleq @q @q\\nsubleq @dv @dv\\nsubleq @dr @dr\\nsubleq @dv @IN\\nsubleq @dr @IN\\n\\n@l2:\\nsubleq @a @dr\\nsubleq @b @b\\nsubleq @b @n1\\nsubleq @b @dv\\nsubleq @b @a @res\\nsubleq @a @a @nextq\\n\\n@nextq:\\nsubleq @dv @dr\\nsubleq @q @1\\nsubleq @a @a @l2\\n\\n@res:\\nsubleq @OUT @q\\nsubleq @OUT @dv\\nsubleq @a @a @loop\\n\\n@a: .data 0\\n@b: .data 0\\n\\n@dv: .data 0\\n@dr: .data 0\\n@q: .data 0\\n\\n@1: .data 1\\n@0: .data 0\\n@n1: .data -1\",\"solutionCycles\":222,\"solutionBytes\":60}],\"currentSolutionName\":\"Untitled (3)\",\"solutionCycles\":222,\"solutionBytes\":60}"}